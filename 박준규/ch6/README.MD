# ⚖️ 6장: static, 제대로 한 번 써 보자

> static은 양날의 검입니다. 제대로 알고 쓰면 시스템 성능을 크게 향상시킬 수 있지만, 잘못 사용하면 심각한 오류와 시스템 장애를 유발할 수 있습니다.

---

## 💡 1. `static`의 핵심 특징

- **하나의 JVM, 하나의 변수**: `static` 변수와 메서드는 객체가 아닌 **클래스**에 속합니다. 따라서 하나의 JVM 안에서는 클래스당 **단 하나의 `static` 변수**만 존재하며, 모든 객체와 스레드가 이를 공유합니다.
- **가장 빠른 초기화**: `static` 변수와 초기화 블록은 클래스가 JVM에 로딩될 때 **단 한 번** 실행됩니다. 객체 생성(생성자 호출)과 무관하게 가장 먼저 준비되는 것입니다.
- **GC 대상이 아님**: `static` 멤버는 클래스가 메모리에서 해제되지 않는 한 **GC(Garbage Collection)의 대상이 되지 않습니다.** 이것이 메모리 릭의 주된 원인이 될 수 있습니다.

---

## 💣 2. `static`을 잘못 사용했을 때의 위험성

### 위험 1: 스레드 안전성 문제 (데이터 오염)

웹 환경처럼 여러 스레드가 동시에 실행되는 곳에서 `static` 변수를 잘못 사용하면 데이터가 엉망이 될 수 있습니다.

`static` 변수는 모든 스레드의 **공용 공간**입니다. 한 스레드가 `static` 변수 값을 바꾸면, 다른 모든 스레드에도 그 변경이 즉시 영향을 미칩니다. 이로 인해 한 사용자의 데이터가 다른 사용자에게 보이는 등의 심각한 문제가 발생할 수 있습니다.

### **Q1. `static`을 잘못 쓰면 왜 시스템이 느려지거나 오류가 생기나요?**

두 가지 최악의 시나리오 때문입니다.

1. **오류 발생 (데이터 오염)**: 여러 사용자가 동시에 접속하는 웹 환경을 생각해 보세요. 만약 특정 사용자의 정보를 `static` 변수에 저장하면, 다른 사용자가 접속하는 순간 그 변수 값을 덮어쓰게 됩니다. A 사용자가 B 사용자의 데이터를 보거나, C 사용자의 주문이 D 사용자에게 넘어가는 등 **데이터가 뒤섞이는 심각한 오류**가 발생합니다. (아래 `queryURL` 예제에서 더 자세히 설명)
2. **시스템 느려짐 & 다운 (메모리 릭)**: `static`으로 선언한 변수는 **GC(메모리 청소부)가 치우지 않습니다.** 만약 `static`으로 만든 리스트나 맵에 계속 데이터를 쌓기만 한다면 어떻게 될까요? 메모리가 가득 차서 더 이상 공간이 없어지고, 결국 **메모리 부족(`OutOfMemoryError`)으로 시스템이 다운**됩니다.

### **Q2. 다른 JVM에서는 `static` 변수가 다른 값을 참조한다는 게 무슨 말인가요?**

`static` 변수는 **하나의 JVM(실행 중인 자바 프로그램 하나) 안에서만** 공유됩니다.

서버 컴퓨터 2대(서버A, 서버B)에서 똑같은 프로그램을 실행하는 상황을 상상해 보세요. 이때 서버A와 서버B는 각각 별개의 JVM을 가동합니다.

- 서버A의 `static` 변수는 서버A 안에서만 공유됩니다.
- 서버B의 `static` 변수는 서버B 안에서만 공유됩니다.

즉, 서버A에서 `static` 변수 값을 아무리 바꿔도 서버B의 `static` 변수에는 아무런 영향이 없습니다. **서로 다른 건물에 있는 별개의 게시판**처럼 완전히 독립적이기 때문입니다.

### **Q3. `queryURL` 예제가 왜 문제가 되는지 이해가 안 돼요.**

이 문제는 **공용 공간**에 **개인 물건**을 둔 것과 같습니다. `static` 변수는 모든 스레드가 함께 쓰는 공용 공간입니다.

**시간 순서로 보는 문제 상황:**

1. **[1ms]** **A 사용자**의 요청을 처리하는 **A 스레드**가 `new BadQueryManager("A쿼리")`를 실행합니다.
   - 공용 공간 `queryURL`에 `"A쿼리"`라는 값이 저장됩니다.
2. **[2ms]** **B 사용자**의 요청을 처리하는 **B 스레드**가 `new BadQueryManager("B쿼리")`를 실행합니다.
   - B 스레드가 공용 공간 `queryURL`의 값을 `"B쿼리"`로 **덮어 써버립니다.** (A의 값은 사라짐)
3. **[3ms]** **A 스레드**가 이어서 `getSql()`을 실행합니다.
   - 이때 참조하는 `queryURL` 값은 A가 원했던 `"A쿼리"`가 아니라, B가 덮어쓴 `"B쿼리"`가 됩니다.

**결과적으로 A 사용자는 엉뚱하게 B 사용자의 데이터를 보게 됩니다.** 이처럼 각 사용자의 요청에 따라 변해야 하는 값은 절대 `static`으로 다루면 안 됩니다.

```java
public class BadQueryManager {
    // ☠️ 모든 스레드가 이 변수 하나를 공유!
    private static String queryURL = null;

    public BadQueryManager(String badUrl) {
        // 생성자가 호출될 때마다 공용 변수의 값이 바뀐다.
        queryURL = badUrl;
    }

    public static String getSql(String idSql) {
        // ...
        // 이 코드가 실행될 때 queryURL이 어떤 값을 가질지 예측할 수 없다.
        HashMap<String, String> document = reader.read(queryURL);
        // ...
    }
}
```

### 위험 2: 메모리 릭 (Memory Leak)

`static`과 `Collection`의 조합은 메모리 릭을 유발하는 최악의 조합이 될 수 있습니다.

만약 `ArrayList`나 `HashMap` 같은 컬렉션을 `static`으로 선언하고, 데이터를 계속 추가만 하고 비우지 않는다면 어떻게 될까요? 해당 컬렉션은 GC의 대상이 되지 않으므로, 담겨있는 객체들도 함께 메모리에 영원히 남게 됩니다. 결국 메모리가 가득 차 **`OutOfMemoryError`**가 발생하며 시스템이 다운됩니다.

---

## ✅ 3. `static` 올바르게 활용하기

### `public static final` - 절대 변하지 않는 상수

가장 안전하고 권장되는 `static`의 사용법입니다. 애플리케이션 전역에서 사용되는 불변의 값을 정의할 때 적합합니다.

### **Q4. JNDI 이름 같은 데이터를 `static`으로 선언하면 편리하다는 게 무슨 말인가요?**

이는 **유지보수성과 가독성** 때문입니다.

자주 사용하지만 절대 변하지 않는 값(예: `"UTF-8"`, DB 연결 이름)을 코드 곳곳에 직접 써넣는다고 생각해 보세요. 만약 이 값을 바꿔야 한다면, 코드의 모든 부분을 찾아다니며 수정해야 하고, 실수로 오타를 낼 수도 있습니다.

하지만 `public static final String ENCODING = "UTF-8";` 처럼 한 곳에 상수로 선언해두면,

- `Constants.ENCODING`처럼 **의미 있는 이름**으로 가져다 쓸 수 있어 코드를 읽기 쉬워집니다.
- 값이 바뀌더라도 **딱 한 곳만 수정**하면 애플리케이션 전체에 적용되므로 유지보수가 매우 편리해집니다.

### **Q5. 설정 파일을 왜 반드시 `static`으로 관리해야 하나요?**

**성능 때문입니다.**

만약 `static`을 쓰지 않는다면, 설정값이 필요할 때마다 매번 디스크에서 파일을 찾아 열고, 읽고, 닫는 **아주 느린 I/O(입출력) 작업**을 반복해야 합니다. 요청이 많아질수록 시스템은 급격히 느려집니다.

`static` 초기화 블록을 사용하면, 프로그램이 시작될 때 **단 한 번만** 이 느린 파일 읽기 작업을 수행합니다. 그 후 결과를 메모리(주로 `static HashMap`)에 저장해두고, 필요할 때마다 **메모리에서 빛의 속도로** 값을 가져옵니다. "한 번만 고생하고 계속 편하게 쓰자"는 전략입니다.

```java
public static final String DEFAULT_ENCODING = "UTF-8";
```

### 무거운 객체를 한 번만 생성하여 공유 (캐싱)

설정 파일 정보, DB 커넥션 풀, 템플릿 엔진처럼 생성 비용이 비싼 객체는 **최초에 한 번만 생성**해서 `static` 변수에 담아두고 재사용하는 것이 성능에 매우 유리합니다.

- **자주 쓰는 DB 데이터 캐싱**: 자주 조회하지만 거의 변하지 않는 코드성 데이터를 매번 DB에서 조회하는 것은 비효율적입니다. 최초 한 번만 DB에서 조회해 `static HashMap`에 담아두면, 이후에는 메모리에서 매우 빠르게 데이터를 가져올 수 있습니다.

> ⚠️ 주의: 여러 서버(JVM)를 사용하는 환경에서는 각 서버의 static 데이터가 다를 수 있습니다. 이 경우, 데이터 일관성을 위해 EhCache, Memcached 같은 분산 캐시 솔루션을 사용하는 것이 올바른 접근법입니다.

---

## 🎯 결론: 모르면 쓰지 마라

- `static`은 잘 쓰면 성능을 높이는 **약**이 되지만, 잘못 쓰면 시스템을 망가뜨리는 **독**이 됩니다.
- `static`으로 선언된 데이터는 객체를 아무리 새로 만들어도 초기화되지 않으며, 모든 곳에서 공유된다는 점을 항상 명심해야 합니다.
- **핵심 원리를 완벽하게 이해하지 못했다면, 차라리 `static`을 사용하지 않는 것이 더 안전한 선택입니다.**
