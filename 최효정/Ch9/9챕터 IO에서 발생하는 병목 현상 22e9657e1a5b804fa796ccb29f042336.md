# 9챕터: IO에서 발생하는 병목 현상

# 9. IO에서 발생하는 병목 현상

---

## IO(Input/Output)의 기본 개념

- **IO란?**
    - 파일, 네트워크, 디바이스 등을 통해 데이터를 읽고 쓰는 모든 작업
    - 예: 파일 읽기/쓰기, 서버 간 데이터 송수신, 콘솔 출력
- 자바에서 IO는 **스트림(Stream)** 을 통해 처리됨
    
    ```java
    System.out.println("Jeremy");
    // out: System 클래스에 정의된 static PrintStream
    // 이 출력도 결국 IO 작업
    
    ```
    
- **IO 작업의 특징**
    - CPU 연산보다 **대기 시간이 길다**
    - 따라서 **시스템 성능의 주요 병목 지점**이 됨

---

## 자바 IO 클래스 구조

### 1) 바이트 기반 스트림 (`InputStream` 하위 클래스)

- `ByteArrayInputStream` : 바이트 배열을 입력 스트림으로 사용
- `FileInputStream` : 바이너리 파일 읽기
- `FilterInputStream` : 다양한 보조 입력 스트림의 추상 클래스
- `ObjectInputStream` : 직렬화된 객체 읽기
- `PipedInputStream` : 다른 스레드에서 출력한 파이프 데이터를 읽음
- `SequenceInputStream` : 여러 개의 스트림을 하나로 연결

### 2) 문자 기반 스트림 (`Reader` 하위 클래스)

- `BufferedReader` : 문자열 단위, 라인 단위 입력 지원 (성능↑)
- `CharArrayReader` : char 배열 입력
- `FilterReader` : 보조 문자 스트림의 추상 클래스
- `FileReader` : 파일 읽기 (문자 기반)
- `InputStreamReader` : 바이트 → 문자 변환
- `PipedReader` : 파이프 입력
- `StringReader` : 문자열을 소스로 읽음

---

## 버퍼링(Buffering)의 효과

- **버퍼(Buffer)**: 데이터를 임시로 저장하는 메모리 공간
- **버퍼링(Buffering)**: 데이터를 버퍼에 모아뒀다가 한꺼번에 읽거나 쓰는 방식 자체를 말함
- 장점:
    1. **시스템 호출 횟수 감소** → OS에 매번 요청하지 않고 버퍼에서 꺼내씀
    2. **IO 속도 향상** → 디스크·네트워크 접근 횟수가 줄어듦
- 성능 비교:

| 방식 | 응답 속도 |
| --- | --- |
| FileReader (버퍼 없음) | 2,480ms |
| FileReader + 버퍼 | 400ms |
| BufferedReader | 350ms |

---

## NIO(New IO, JDK 1.4~)

- 기존 IO의 한계(많은 복사와 대기)를 보완하기 위해 등장
- IO 병목을 완전히 해결하지는 못하지만, 성능 최적화를 위해 여러 기능 제공

### 전통적인 파일 읽기 과정

1. 자바 메서드가 파일 읽기 요청
2. OS 커널이 디스크에서 데이터를 읽어 **커널 버퍼**에 저장
3. JVM은 커널 버퍼에서 JVM 메모리로 복사
4. 자바 스트림 클래스가 데이터를 처리

→ **문제점**: 불필요한 복사 과정과 대기 시간이 많음

### NIO가 도입한 개념

- **버퍼(Buffer)** : 데이터를 모아서 효율적으로 처리
- **채널(Channel)** : 스트림과 달리 양방향 데이터 전송 가능
- **인코더/디코더** : 바이트 ↔ 문자 변환 지원
- **정규 표현식 기반 패턴 매칭** 지원
- **파일 잠금 / 메모리 매핑** 제공
- **Non-blocking IO** : 서버에서 동시에 많은 연결 처리 가능

---

## DirectByteBuffer와 성능 이슈

- NIO를 사용할 때 ByteBuffert사용하는 경우 많음

### ByteBuffer 생성 방법

- `wrap()` : 기존 배열 감싸기
- `allocate()` : JVM 힙 메모리에 버퍼 생성
- `allocateDirect()` : OS 메모리에 직접 할당 → JNI로 접근

### 잘못된 사용 예

```java
public ByteBuffer getDirectByteBuffer() {
  return ByteBuffer.allocateDirect(65536);  // OS 메모리에 직접 할당
}

public static void main(String[] args) {
  for (int loop = 1; loop < 1024000; loop++) {
    ByteBuffer buffer = getDirectByteBuffer();
    
    //루프를 돌 때마다 새로운 DirectByteBuffer를 계속 생성
크기 65KB짜리 버퍼를 102만 번 생성 → 엄청난 OS 메모리 요청
    if (loop % 100 == 0) {
      System.out.println(loop);
    }
  }
}

```

- 실행 결과: **5~10초마다 Full GC 발생**
- Old 영역 메모리 사용량은 증가하지 않음

### 원인 분석

- `DirectByteBuffer` 생성자 → 내부에서 `Bits.reserveMemory()` 호출
- 메모리 부족 시 `System.gc()` 강제 호출
- 따라서 빈번히 `allocateDirect()` 호출 시 불필요한 Full GC 발생 → 성능 저하

### 해결책

- DirectByteBuffer는 **빈번히 생성하지 말 것**
- **싱글톤 패턴** 또는 **객체 풀링(pooling)** 사용
- OS 메모리를 직접 다루는 만큼 **재사용 전략** 필수

---

## 핵심 정리

1. IO는 CPU 연산보다 **대기 시간이 길어 성능 병목의 주요 원인**
2. 버퍼링을 활용하면 성능을 크게 개선할 수 있음
3. NIO는 버퍼·채널·논블로킹 IO 등 새로운 기능을 도입해 효율적인 IO 지원
4. DirectByteBuffer는 OS 메모리를 활용해 빠르지만, 잘못 쓰면 GC 폭탄이 발생
5. 따라서 DirectByteBuffer는 반드시 **재사용 패턴**으로 관리해야 함