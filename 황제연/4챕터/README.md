# 자바 컬렉션 프레임워크
자바 컬렉션 프레임워크는 List, Set, Map 세 가지 주요 인터페이스를 중심으로 다양한 구현체를 제공합니다 
각 구현체는 내부 데이터 구조에 따라 시간 복잡도, 메모리 특성, 그리고 특정 연산에서의 성능이 달라집니다

# List 계열: 순서 있는 요소, 중복 허용

## ArrayList: 
동적 배열 기반의 리스트로, 원소를 순차적으로 저장하며 필요에 따라 배열 크기를 동적으로 확장합니다
### 성능 
조회(get)의 시간복잡도가 O(1)로 빠르며, 맨 뒤에 추가(add)되는 것도 O(1)로 빠릅니다 
이는 배열의 연속적인 메모리 할당 덕분에 메모리 지역성이 우수하여 캐시 효율이 높기 때문입니다

하지만 "중간 요소를 삽입/삭제하거나 그 위치에서 이후의 요소들을 한 칸씩 밀거나 당겨야 하기 때문에 O(n) 시간이 걸립니다 
그중 맨 앞의 삭제는 가장 느린 O(n) 비용이 발생합니다

### 메모리 
배열로 원소를 연속 저장하므로 메모리 지역성(locality)이 좋아 반복 접근이 빠릅니다
다만 사용 중이지 않은 만큼에 대해서는 공간을 차지한다는 단점이 있습니다


## 사용해야하는 상황
인덱스를 통한 빠른 접근과 순차적 처리가 필요한 경우에 가장 적합합니다
요소 추가/삭제가 주로 리스트 끝에서 발생하는 경우 효율적입니다.

## 사용하지 말아야 하는상황
맨 앞이나 중간에 빈번한 삽입/삭제가 발생하면 성능 저하가 크기 때문에 빈번한 추가/삭제가 있는 경우 피하는 것이 좋습니다 
또한 멀티스레드 환경에서는 Thread-Safe하지 않아 Collections.synchronizedList 등으로 감싸는 방법을 선택해야 합니다


## LinkedList 
이중 연결 리스트 기반으로, 각 요소(Node)가 이전/다음 노드의 참조를 가집니다 
List 외에 Deque(양쪽 끝 삽입/삭제) 및 Queue 인터페이스도 구현할 수 있습니다

### 성능 
조회(get)의 시간복잡도는 O(n)으로 상대적으로 느립니다. 
그 이유는 원소를 찾을 때까지 순차적으로 각 노드를 탐색하기 떄문입니다
반면 맨 앞/뒤에 추가(addFirst/Last)는 노드 연결만 변경하면 되기 때문에 O(1)의 시간복잡도를 가집니다

중간 삽입/삭제도 해당 위치 노드 참조를 알고 있으면 노드 연결 변경만으로 O(1)에 가능하지만, 
일반적으로는 탐색 후 작업하기 때문에 평균 O(n)의 시간복잡도를 가집니다

## 메모리 
각 요소를 담는 노드 객체가 별도로 존재하고, 
노드마다 데이터 외에 두 개의 포인터(이전/다음 노드 참조)를 저장하므로 메모리 오버헤드가 높습니다 
또한 메모리 비연속성으로 캐시 지역성이 떨어져 성능도 저하될 수 있습니다

## 사용해야하는 상황
리스트의 처음이나 끝에서 빈번한 삽입/삭제가 일어나는 경우 성능상 이점이 있으므로 사용하기 좋습니다

## 사용하지 말아야 하는상황
조회가 느리고(O(n)), 메모리 사용량이 많습니다
심지어 순차 반복조차 ArrayList보다 느린 경우가 많습니다


# Vector
ArrayList와 유사한 동적 배열 기반이지만, 
모든 메소드가 synchronized로 동기화되어 Thread-Safe합니다

## 성능
단일 스레드 상황에서 ArrayList보다 약간 느립니다. 이유는 동기화 오버헤드 때문입니다
멀티스레드 환경에서 Thread-Safe하다는 장점을 제공합니다

# Map 계열: 키-값 쌍 저장, 키 중복 불가

## HashMap
해시 테이블 기반의 맵으로, 키의 hashCode()를 이용하여 해시 테이블 인덱스를 계산하고 
[Key, Value] 엔트리를 저장합니다. 순서는 보장되지 않습니다

## 성능 
평균적으로 검색(get), 삽입(put), 삭제(remove) 모두 O(1)로 빠릅니다.
자바 8 이후로는 충돌 시 개별 버킷을 트리화하여 최악의 경우도 O(log n)으로 개선되었습니다.
(자바 7까지는 최악 O(n))

## 메모리
키와 값을 포함하는 엔트리 객체(Node)와 버킷용 배열을 갖습니다 
자바 8부터는 첫 put 시점에 초기화하여 불필요한 메모리 할당을 줄이는 최적화(lazy initialization)가 도입되었습니다

## 장점
키로 값 검색이 빈번한 상황에 최적입니다. 
캐싱, 딕셔너리 조회 등에 쓰이며, 대부분의 상황에서 자바 컬렉션 중 가장 빠른 Map 구현체입니다

## 단점
순서를 보장하지 않기 때문에 입력 순서나 정렬이 필요한 경우 부적합합니다
키 객체는 hashCode()/equals()를 정확히 구현해야 하며, 가변 객체를 키로 사용할 때 주의해야 합니다.

## 기타
멀티스레드 환경에서는 직접 사용하면 안 됩니다 
현대 자바에서는 ConcurrentHashMap을 통해 구현해야 합니다

# LinkedHashMap 
HashMap을 상속하여 엔트리를 이중 연결 리스트로 연결함으로써 삽입 순서(또는 접근 순서)를 유지하는 맵입니다

## 성능
기본 연산(put/get/remove)은 HashMap과 동일하게 평균 O(1)입니다

##  메모리 
각 엔트리가 이전/다음 엔트리의 참조 포인터 두 개를 추가로 가지므로 HashMap보다 메모리 소비가 조금 더 높습니다

## 장점
예측 가능한 순회 순서를 제공합니다.
LRU 캐시 구현처럼 최근 사용된 순서로 정렬해야 할 경우에 유용합니다 

## 단점
HashMap보다 약간의 성능/메모리 오버헤드가 있습니다. 
정렬된 순서가 아닌 삽입(또는 접근) 순서만 보존합니다
또한 멀티스레드 환경에서는 thread-unsafe합니다.

## TreeMap
레드-블랙 트리 기반의 이진 탐색 트리 맵입니다 
NavigableMap/SortedMap 인터페이스 구현체로, 키를 항상 오름차순으로 정렬하여 저장합니다

## 성능 
TreeSet과 유사하게 삽입(put), 검색(get), 삭제(remove)가 모두 O(log n)입니다.
균형 트리 유지 비용으로 HashMap보다 느립니다

## 장점
키가 항상 정렬된 상태로 유지되므로, 정렬된 출력이나 범위 검색 등에 매우 유용합니다.
subMap 등의 부분 범위 데이터 추출 및 higherKey, lowerEntry 등 주변 키 탐색을 지원합니다

## 단점
HashMap보다 느린 성능이 단점입니다 
따라서 정렬이 불필요한 경우 비효율적입니다

## Hashtable
 자바 1.0부터 존재한 해시 테이블 기반 Map으로, HashMap과 유사하나 
 모든 메소드가 synchronized되어 Thread-Safe합니다. 현재는 거의 사용되지 않습니다

## 성능
멀티스레드 환경을 가정하지 않으면, HashMap 대비 느립니다. 
단일 락으로 심각한 병목이 발생하고, 자바 8 이후의 HashMap 개선(트리화 등)이 Hashtable에는 적용되지 않았습니다

만약 동기화된 Map이 필요하면 Hashtable 대신 ConcurrentHashMap을 사용하는 것이 권장됩니다

# Set 계열: 중복 없는 고유 원소 집합

## HashSet: 
해시 테이블 기반의 집합으로, 내부적으로 HashMap을 사용합니다 
HashSet은 요소의 순서를 보장하지 않습니다

## 성능 
평균적으로 삽입(add), 검색(contains), 삭제(remove) 모두 
평균 O(1) 시간복잡도로 매우 효율적인 자료 구조입니다
자바 8부터 HashSet에 일정 수 이상 노드가 쌓이면 Red-Black Tree로 변환하여 
최악 성능을 O(log n)으로 개선했습니다. (자바 7까지는 최악 O(n))

## 장점 
중복 없이 빠른 검색이 필요한 상황에 적합합니다 
집합 연산이나 포함 여부 검사에 유리하며, 평균 성능이 뛰어납니다

## 단점
저장 순서가 유지되지 않아 순회 결과의 예측이 불가능합니다 

## 기타
thread-unsafe하기때문에, 멀티스레드에서는 ConcurrentHashMap 기반의 동시성 Set이 필요합니다

# LinkedHashSet: 
HashSet을 확장하며, 이중 연결 리스트로 요소의 삽입 순서를 유지합니다 
내부적으로 LinkedHashMap을 사용합니다.

## 성능 
기본 동작은 HashSet과 동일하게 평균적인 상황에서 시간복잡도 O(1) 성능을 가집니다 
순회는 삽입 순서대로 진행됩니다.

## 메모리
각 노드가 앞뒤를 연결하는 포인터를 추가로 가져 HashSet보다 메모리 사용이 높습니다

## 장점 
입력 순서를 유지해야 하는 Set이 필요할 때 사용하기 좋습니다
빠른 검색과 순서 유지를 모두 제공합니다.

## 단점 
HashSet 대비 약간의 메모리/연산 오버헤드가 있습니다 
정렬 순서는 지원하지 않고 삽입된 순서만 보존합니다

# TreeSet 
레드-블랙 트리 기반의 정렬 이진트리로 구현됩니다
NavigableSet/SortedSet 인터페이스를 구현하여 요소들이 정렬된 상태로 저장됩니다

## 성능 
삽입(add), 검색(contains), 삭제(remove)가 모두 O(log n)의 시간이 걸립니다 
이는 트리 높이에 비례하는 탐색이 필요하기 때문입니다 

HashSet보다는 느리지만 정렬된 순서를 유지하기 위해 사용되며, 반복은 오름차순으로 진행됩니다

## 메모리 
각 요소를 노드로 가지는 트리 구조로, 포인터(부모, 자식) 및 균형 트리 유지 정보를 포함하여 
HashSet보다 요소당 메모리 오버헤드가 높습니다.

## 장점 
자동 정렬의 장점을 가지며, 삽입과 동시에 정렬이 필요할 때 유용합니다, 
NavigableSet API를 통해 범위 검색(subSet)이나 이진 탐색 유사 조회(higher(), lower()) 기능을 제공합니다

## 단점
동일한 작업에서 HashSet보다 느립니다 
데이터 양이 방대하고 순서가 필요 없을 경우 비효율적입니다

## 기타
Comparator를 전달하여 사용자 정의 순서를 적용할 수 있습니다 
멀티스레드 환경에서는 thread-unsafe하므로 ConcurrentSkipListSet 등을 고려해야 합니다
